import {
  Canvas,
  Meta,
  Controls,
  Unstyled,
  Story,
} from "@storybook/addon-docs/blocks"
import LinkTo from "@storybook/addon-links/react"
import * as TableStories from "./table.stories"

<Meta title="Data Collection/Visualizations/Table" />

# Table Visualization

## Introduction

The Table visualization is a tabular visualization that displays data in rows
and columns with advanced features like column sorting, filtering, frozen
columns, column reordering, and column hiding. It provides a comprehensive view
of structured data with enhanced interactivity.

## Examples

<Canvas of={TableStories.BasicListVisualization} />

## Setting Up Table Visualization

To enable the Table visualization in your data collection component, provide the
`type: "table"` in the `visualizations` prop:

```tsx
<OneDataCollection
  source={dataSource}
  visualizations={[
    {
      type: "table",
      options: {
        columns: [
          {
            label: "Name",
            render: (item) => item.name,
            sorting: "name",
            width: 140,
          },
          {
            label: "Email",
            render: (item) => item.email,
            sorting: "email",
          },
          {
            label: "Role",
            render: (item) => item.role,
            sorting: "role",
          },
          {
            label: "Department",
            render: (item) => item.department,
            sorting: "department",
          },
        ],
      },
    },
  ]}
/>
```

## Table Properties

```ts
type TableVisualizationOptions<T> = {
  /**
   * The columns to display
   */
  columns: ReadonlyArray<TableColumnDefinition<T>>

  /**
   * The number of columns to freeze on the left
   */
  frozenColumns?: 0 | 1 | 2

  /**
   * Allow users to reorder columns (you can only reorder columns that are not frozen)
   */
  allowColumnReordering?: boolean

  /**
   * Allow users to hide columns (you can define specifically non hideable columns in col props, also frozen columns are not hideable)
   */
  allowColumnHiding?: boolean
}
```

## Table Column Definition

```ts
type TableColumnDefinition<T> = {
  /**
   * The id of the column. This is used to identify the column and is used to hide and order the columns and is required if you want to use the column hiding and ordering features.
   */
  id: string

  /**
   * The label to display for the column header.
   */
  label: string

  /**
   * The function to render the column content.
   */
  render: (item: T) => DisplayValueDefinition

  /**
   * The sorting key for this column.
   */
  sorting?: string

  /**
   * The alignment of the column. If not provided, the alignment will be "left"
   */
  align?: "left" | "right"

  /**
   * The width of the column. If not provided, the width will be "auto"
   */
  width?: number

  /**
   * The initial state of the hidden (only applies if allowColumnHiding is true)
   */
  hidden?: boolean

  /**
   * Avoid hiding the column by the user
   */
  noHiding?: boolean

  /**
   * The initial order of the column
   */
  order?: number

  /**
   * Optional summary configuration for this column
   */
  summary?: string

  /**
   * Additional information to display in the column header
   */
  info?: string

  /**
   * Icon to display next to the info text
   */
  infoIcon?: IconType
}
```

## Complete Example

```tsx
<OneDataCollection
  source={dataSource}
  visualizations={[
    {
      type: "table",
      options: {
        frozenColumns: 1,
        allowColumnReordering: true,
        allowColumnHiding: true,
        columns: [
          {
            label: "Name",
            width: 140,
            render: (item) => ({
              type: "person",
              value: {
                firstName: item.name.split(" ")[0],
                lastName: item.name.split(" ")[1],
              },
            }),
            sorting: "name",
            noHiding: true,
          },
          {
            label: "Email",
            render: (item) => item.email,
            sorting: "email",
            align: "left",
          },
          {
            label: "Role",
            render: (item) => item.role,
            sorting: "role",
            info: "User's current role in the organization",
          },
          {
            label: "Department",
            render: (item) => ({
              type: "dotTag",
              value: {
                color: "blue",
                label: item.department,
              },
            }),
            sorting: "department",
            align: "left",
          },
          {
            label: "Status",
            render: (item) => ({
              type: "status",
              value: {
                status: item.status === "active" ? "positive" : "critical",
                label:
                  item.status.charAt(0).toUpperCase() + item.status.slice(1),
              },
            }),
            sorting: "status",
            align: "center",
          },
          {
            label: "Manager",
            render: (item) => ({
              type: "person",
              value: {
                firstName: item.manager.split(" ")[0],
                lastName: item.manager.split(" ")[1],
              },
            }),
            hide: (item) => item.name.startsWith("D"),
            sorting: "manager",
          },
          {
            label: "Permissions",
            render: (item) =>
              [
                item.permissions?.read ? "Read" : "",
                item.permissions?.write ? "Write" : "",
                item.permissions?.delete ? "Delete" : "",
              ]
                .filter(Boolean)
                .join(", "),
            sorting: "permissions.read",
            align: "right",
            hidden: true, // Initially hidden
          },
        ],
      },
    },
  ]}
/>
```

## Advanced Features

### Frozen Columns

You can freeze columns to the left side of the table to keep them visible while
scrolling horizontally:

```tsx
{
  type: "table",
  options: {
    frozenColumns: 2, // Freeze first 2 columns
    columns: [
      // ... your columns
    ],
  },
}
```

<Canvas of={TableStories.TableFrozenCols} meta={TableStories} />

### Column Ordering

Using the `order` property you can define the initial order of the columns.

```tsx
{
  type: "table",
  options: {
    columns: [
      {
        label: "Role",
        render: (item) => item.role,
      },
      {
        label: "Name",
        render: (item) => item.name,
        order: 3
      },
    ],
  },
}
```

If no order is provided, the column will be placed at the end of the table.

### Column Reordering

Allow users to reorder columns by drag and drop:

```tsx
{
  type: "table",
  options: {
    allowColumnReordering: true,
    columns: [
      {
        label: "Name",
        render: (item) => item.name,
        order: 3
      },
      {
        label: "Email",
        render: (item) => item.email,
        hidden: true, // Initially hidden
        order: 1
      },

      // ... more columns
    ],
  },
}
```

### Column Hiding

Allow users to show/hide columns using column settings:

```tsx
{
  type: "table",
  options: {
    allowColumnHiding: true,
    columns: [
      {
        label: "Name",
        render: (item) => item.name,
        noHiding: true, // This column cannot be hidden
      },
      {
        label: "Email",
        render: (item) => item.email,
        hidden: true, // Initially hidden
      },
      // ... more columns
    ],
  },
}
```

<Canvas of={TableStories.TableColumnOrderingAndHidden} meta={TableStories} />

## Nested Tables

Tables can display hierarchical data by allowing rows to be expanded to reveal
child items. This functionality is useful for representing tree structures,
categories with subcategories, or any parent-child relationship in your data.

### Basic Setup

To enable nested tables, you need to provide three methods in your data source:

```tsx
<OneDataCollection
  source={{
    dataAdapter: myDataAdapter,
    itemsWithChildren: (item) => !!item.children?.length,
    childrenCount: ({ item }) => item.children?.length,
    fetchChildren: async ({ item, filters, pagination, sortings }) => {
      const children = await fetchChildrenFromAPI(item.id)
      return {
        records: children,
        type: "basic",
      }
    },
  }}
  visualizations={[
    {
      type: "table",
      options: {
        columns: [
          // ... your columns
        ],
      },
    },
  ]}
/>
```

### Required Methods

#### `itemsWithChildren`

**Type:** `(item: R) => boolean`

Function that determines if an item has children and therefore should display
the expand button.

**Example:**

```tsx
itemsWithChildren: (item) => {
  // Option 1: Based on a property
  return !!item.children?.length

  // Option 2: Based on a flag
  return item.hasChildren === true

  // Option 3: Based on business logic
  return item.type === "folder"
}
```

#### `childrenCount`

**Type:**
`({ item, pagination }: { item: R; pagination?: ChildrenPaginationInfo }) => number | undefined`

Function that returns the total number of child items an element has. This
number is displayed next to the expand button and helps the user understand how
many items they will see when expanding.

**Parameters:**

- `item`: The parent item whose child count we want to know
- `pagination`: (Optional) Current pagination information of the children,
  useful if you need to calculate the total based on pagination state

**Example:**

```tsx
childrenCount: ({ item, pagination }) => {
  // Option 1: Return array length
  return item.children?.length

  // Option 2: Return a server counter
  return item.childrenTotal

  // Option 3: Use pagination information
  return pagination?.total ?? item.childrenCount

  // Option 4: Return undefined if unknown
  return item.hasChildren ? undefined : 0
}
```

**Note:** If you return `undefined`, no counter will be displayed next to the
expand button, but the button will still work.

#### `fetchChildren`

**Type:**
`({ item, filters, pagination }: { item: R; filters?: FiltersState<Filters>; pagination?: ChildrenPaginationInfo }) => Promise<ChildrenResponse<R>>`

Async function that fetches the child items of a parent item. This is the main
method that controls how hierarchical data is loaded.

**Parameters:**

- `item`: The parent item whose children will be loaded
- `filters`: (Optional) Current filter state applied in the table. You can use
  these filters to also filter child items
- `pagination`: (Optional) Pagination information for loading more children
  incrementally

**Returns:** `Promise<ChildrenResponse<R>>`

```ts
type ChildrenResponse<R> = {
  // Array of child items
  records: R[]

  // Response type: "basic" or "detailed"
  type?: "basic" | "detailed"

  // Pagination information for loading more items
  paginationInfo?: ChildrenPaginationInfo
}

type ChildrenPaginationInfo = {
  total: number // Total available items
  perPage: number // Items per page
  currentPage: number // Current page
  pagesCount: number // Total pages
  hasMore: boolean // If there are more items to load
}
```

### Response Types: `basic` vs `detailed`

The `type` field in the `fetchChildren` response controls the visual layout of
child items. Both types support expandable children, but they differ in their
presentation:

#### `"basic"` (default)

Children are displayed in a **hierarchical tree view** with visual connectors
and indentation. This creates a traditional tree structure that clearly shows
the parent-child relationships. Use this type when:

- You want a clear hierarchical visualization
- Visual tree structure is important for understanding relationships
- You need a compact view with indented children

```tsx
fetchChildren: async ({ item }) => {
  const children = await fetchChildrenFromElement(item.id)
  return {
    records: children,
    type: "basic", // Hierarchical tree view with connectors
  }
}
```

**Visual example:**

```
ğŸ“ Main Folder (expandable)
  â”œâ”€ ğŸ“ Subfolder 1 (expandable)
  â”‚   â”œâ”€ ğŸ“„ File 1.1
  â”‚   â””â”€ ğŸ“„ File 1.2
  â”œâ”€ ğŸ“ Subfolder 2 (expandable)
  â”‚   â””â”€ ğŸ“„ File 2.1
  â””â”€ ğŸ“„ File 3
```

<Canvas of={TableStories.TableWithNestedRecords} meta={TableStories} />

#### `"detailed"`

Children are displayed **aligned with the parent** without tree connectors or
indentation. This creates a flatter, more detailed view where children are
treated as full table rows. Use this type when:

- You need to display detailed information for the parent
- You prefer a cleaner, less hierarchical appearance

```tsx
fetchChildren: async ({ item }) => {
  const children = await fetchChildrenFromAPI(item.id)
  return {
    records: children,
    type: "detailed", // Aligned view without tree connectors
  }
}
```

**Visual example:**

```
ğŸ“ Main Folder (expandable)
ğŸ“„ File 1.1 (child)
ğŸ“„ File 1.2 (child)
ğŸ“ Subfolder 2 (expandable)
ğŸ“„ File 2.1 (child)
ğŸ“„ File 3 (child)
```

<Canvas of={TableStories.TableWithNestedRecordsDetailed} meta={TableStories} />

**Example with dynamic type:**

```tsx
fetchChildren: async ({ item }) => {
  const children = await fetchChildrenFromElement(item.id)

  return {
    records: children,
    // Use tree view for folders, detailed view for other items
    type: item.type === "folder" ? "basic" : "detailed",
  }
}
```

### Children Pagination

When a parent item has many children, you can implement pagination to load them
incrementally. This significantly improves performance and user experience.

#### Pagination Setup

```tsx
fetchChildren: async ({ item, filters, pagination }) => {
  // First load (pagination is undefined)
  if (!pagination) {
    const firstPage = await fetchChildrenFromElement(item.id, {
      page: 1,
      perPage: 10,
    })

    return {
      records: firstPage.data,
      type: "detailed",
      paginationInfo: {
        total: firstPage.total,
        perPage: 10,
        currentPage: 1,
        pagesCount: Math.ceil(firstPage.total / 10),
        hasMore: firstPage.total > 10,
      },
    }
  }

  // Subsequent loads (when user clicks "Load more")
  const nextPage = await fetchChildrenFromElement(item.id, {
    page: pagination.currentPage + 1,
    perPage: pagination.perPage,
  })

  return {
    records: nextPage.data,
    type: "detailed",
    paginationInfo: {
      total: pagination.total,
      perPage: pagination.perPage,
      currentPage: pagination.currentPage + 1,
      pagesCount: pagination.pagesCount,
      hasMore: pagination.currentPage + 1 < pagination.pagesCount,
    },
  }
}
```

#### "Load More" Behavior

When `paginationInfo.hasMore` is `true`, a "Load more" button is automatically
shown at the end of the expanded children. When clicked:

1. `fetchChildren` is called with the current `pagination`
2. New items are **appended** to existing ones (they don't replace them)
3. Pagination information is updated
4. The "Load more" button is hidden when `hasMore` is `false`

### Complete Example with all nested table features

```tsx
<OneDataCollection
  source={{
    dataAdapter: myDataAdapter,

    // Determine which items have children
    itemsWithChildren: (item) => {
      return item.type === "folder" || item.childrenCount > 0
    },

    // Show the number of children
    childrenCount: ({ item, pagination }) => {
      // If there's pagination, use pagination total
      if (pagination?.total !== undefined) {
        return pagination.total
      }
      // Otherwise, use item counter
      return item.childrenCount
    },

    // Load children with pagination
    fetchChildren: async ({ item, filters, pagination }) => {
      const page = pagination ? pagination.currentPage + 1 : 1
      const perPage = 20

      // Call your API
      const response = await fetchChildrenFromElement(
        item.id,
        {
          page: page,
          perPage: perPage,
        },
        filters
      )

      return {
        records: data.children,
        // Allow children to expand only if level is less than 3
        type: item.level < 3 ? "detailed" : "basic",
        paginationInfo: {
          total: data.total,
          perPage: perPage,
          currentPage: page,
          pagesCount: Math.ceil(data.total / perPage),
          hasMore: page * perPage < data.total,
        },
      }
    },
  }}
  visualizations={[
    {
      type: "table",
      options: {
        columns: [
          {
            id: "name",
            label: "Name",
            render: (item) => ({
              type: "text",
              value: item.name,
            }),
          },
          {
            id: "type",
            label: "Type",
            render: (item) => ({
              type: "status",
              value: {
                label: item.type,
                status: item.type === "folder" ? "neutral" : "positive",
              },
            }),
          },
        ],
      },
    },
  ]}
/>
```

<Canvas of={TableStories.TableWithMixedNestedRecords} meta={TableStories} />
